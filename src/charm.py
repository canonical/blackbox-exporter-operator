#!/usr/bin/env python3
# Copyright 2026 sina.pahlavan@canonical.com
# See LICENSE file for licensing details.

"""Charm the application."""

import logging
import os

import ops
from charms.operator_libs_linux.v2 import snap
from charms.prometheus_k8s.v0.prometheus_scrape import MetricsEndpointProvider
from ops.model import ActiveStatus, MaintenanceStatus

from constants import PROBES_RELATION_NAME
from singleton_snap import SingletonSnapManager
from snap_management import (
    SnapMap,
    SnapServiceError,
    SnapSpecError,
    install_snap,
)

logger = logging.getLogger(__name__)


def event() -> str:
    """Return Juju hook|action name.

    Refs:
    - https://github.com/juju/juju/blob/cbb05654c7444dd6bee29e49aff16339f02c34f9/docs/reference/action.md?plain=1#L55
    - https://github.com/juju/juju/blob/cbb05654c7444dd6bee29e49aff16339f02c34f9/docs/reference/hook.md?plain=1#L1088
    """
    return os.environ.get("JUJU_HOOK_NAME") or os.environ.get("JUJU_ACTION_NAME", "")


class BlackboxExporterOperatorCharm(ops.CharmBase):
    """Charm the application."""

    def __init__(self, framework: ops.Framework):
        super().__init__(framework)
        if event() in ("install", "upgrade"):
            self._install_snaps()
        elif event() == "remove":
            self._remove_blackbox_exporter()
            return

        self._reconcile()

    def _reconcile(self):
        self._scraping = MetricsEndpointProvider(
            self,
            relation_name=PROBES_RELATION_NAME,
            # TODO: this needs to be equal to the jobs specified by _generate_scrape_jobs
            # and the probes_file config option (to be added)
            jobs=[],
            refresh_event=[
                self.on.config_changed,
                self.on.update_status,
            ],
        )

        self.unit.status = ActiveStatus()

    def snap(self, snap_name: str) -> snap.Snap:
        """Return the snap object for the given snap.

        This method provides lazy initialization of snap objects, avoiding unnecessary
        calls to snapd until they're actually needed.
        """
        return snap.SnapCache()[snap_name]

    def _install_snaps(self) -> None:
        manager = SingletonSnapManager(self.unit.name)

        for snap_name in SnapMap.snaps():
            snap_revision = SnapMap.get_revision(snap_name)
            manager.register(snap_name, snap_revision)
            revisions = manager.get_revisions(snap_name)
            if snap_revision >= (max(revisions) if revisions else 0):
                # Install the snap
                self.unit.status = MaintenanceStatus(f"Installing {snap_name} snap")
                install_snap(snap_name)
                # Start the snap
                self.unit.status = MaintenanceStatus(f"Starting {snap_name} snap")
                try:
                    self.snap(snap_name).start(enable=True)
                except snap.SnapError as e:
                    raise SnapServiceError(f"Failed to start {snap_name}") from e

    def _remove_blackbox_exporter(self):
        """Coordinate blackbox-exporter snap and config file removal."""
        manager = SingletonSnapManager(self.unit.name)
        snap_name = "prometheus-blackbox-exporter"
        snap_revision = SnapMap.get_revision(snap_name)
        manager.unregister(snap_name, snap_revision)
        if manager.is_used_by_other_units(snap_name):
            try:
                self.snap(snap_name).restart()
            except snap.SnapError as e:
                logger.warning(f"Failed to restart prometheus-blackbox-exporter snap: {e}")
        else:
            try:
                self._remove_snap(snap_name)
                logger.info("Removed the prometheus-blackbox-exporter snap")
            except Exception as e:
                logger.warning(f"Unable to remove the prometheus-blackbox-exporter snap: {e}")

    def _remove_snap(self, snap_name: str):
        """Attempt to remove the snap."""
        self.unit.status = MaintenanceStatus(f"Uninstalling {snap_name} snap")
        try:
            self.snap(snap_name).ensure(state=snap.SnapState.Absent)
            logger.info(f"{snap_name} snap was uninstalled")
        except (snap.SnapError, SnapSpecError) as e:
            # Log error but don't fail the remove hook - this is common in test environments
            logger.error(f"Failed to uninstall {snap_name} snap: {e}")
            # Don't raise the exception to avoid failing the remove hook

    def _generate_scrape_jobs(self):
        """Scrape jobs from peer relation data will be generated by this method."""
        # TODO: implement this method.
        pass


if __name__ == "__main__":  # pragma: nocover
    ops.main(BlackboxExporterOperatorCharm)
