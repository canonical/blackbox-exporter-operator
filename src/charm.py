#!/usr/bin/env python3
# Copyright 2026 sina.pahlavan@canonical.com
# See LICENSE file for licensing details.

"""Charm the application."""

import logging

import os
import ops
from charms.prometheus_k8s.v0.prometheus_scrape import MetricsEndpointProvider
from charms.operator_libs_linux.v2 import snap 
from constants import PROBES_RELATION_NAME
from ops import BlockedStatus, CharmBase, RelationChangedEvent
from ops.model import ActiveStatus, MaintenanceStatus, WaitingStatus
from singleton_snap import SingletonSnapManager
from snap_management import (
    SnapMap,
    SnapServiceError,
    SnapSpecError,
    install_snap,
)

# A standalone module for workload-specific logic (no charming concerns):
# TODO: remove this import and blackbox_exporter.py
import blackbox_exporter

logger = logging.getLogger(__name__)

def event() -> str:
    """Return Juju hook|action name.

    Refs:
    - https://github.com/juju/juju/blob/cbb05654c7444dd6bee29e49aff16339f02c34f9/docs/reference/action.md?plain=1#L55
    - https://github.com/juju/juju/blob/cbb05654c7444dd6bee29e49aff16339f02c34f9/docs/reference/hook.md?plain=1#L1088
    """
    return os.environ.get("JUJU_HOOK_NAME") or os.environ.get("JUJU_ACTION_NAME", "")

class BlackboxExporterOperatorCharm(ops.CharmBase):
    """Charm the application."""

    def __init__(self, framework: ops.Framework):
        super().__init__(framework)
        if event() in ("install", "upgrade"):
            self._install_snaps()
        elif event() == "remove":
            # NOTE: We need to clean up the config file and uninstall the snap(s). If we do this
            # on the stop hook, then it will be reverted by the reconciler on `peer_relation_*`
            # hooks. Instead of filtering out these hooks, we do everything in the remove hook.
            # https://documentation.ubuntu.com/juju/3.6/reference/hook/#remove
            self._cleanup_certificates_on_remove()
            self._remove_node_exporter()
            self._remove_opentelemetry_collector()
            return
        framework.observe(self.on.install, self._on_install)
        framework.observe(self.on.start, self._on_start)

        self._scraping = MetricsEndpointProvider(
            self,
            relation_name=PROBES_RELATION_NAME,
            jobs=[], # TODO: this needs to be equal to the jobs specified by _generate_scrape_jobs and the probes_file config option (to be added)
            refresh_event=[
                self.on.config_changed,
                self.on.update_status,
            ],
        )

    def snap(self, snap_name: str) -> snap.Snap:
        """Return the snap object for the given snap.

        This method provides lazy initialization of snap objects, avoiding unnecessary
        calls to snapd until they're actually needed.
        """
        return snap.SnapCache()[snap_name]

    def _on_install(self, event: ops.InstallEvent):
        """Install the workload on the machine."""
        blackbox_exporter.install()

    def _on_start(self, event: ops.StartEvent):
        """Handle start event."""
        self.unit.status = ops.MaintenanceStatus("starting workload")
        blackbox_exporter.start()
        version = blackbox_exporter.get_version()
        if version is not None:
            self.unit.set_workload_version(version)
        self.unit.status = ops.ActiveStatus()
    
    def _install_snaps(self) -> None:
        manager = SingletonSnapManager(self.unit.name)

        for snap_name in SnapMap.snaps():
            snap_revision = SnapMap.get_revision(snap_name)
            manager.register(snap_name, snap_revision)
            revisions = manager.get_revisions(snap_name)
            if snap_revision >= (max(revisions) if revisions else 0):
                # Install the snap
                self.unit.status = MaintenanceStatus(f"Installing {snap_name} snap")
                install_snap(snap_name)
                # Start the snap
                self.unit.status = MaintenanceStatus(f"Starting {snap_name} snap")
                try:
                    self.snap(snap_name).start(enable=True)
                except snap.SnapError as e:
                    raise SnapServiceError(f"Failed to start {snap_name}") from e

    def _generate_scrape_jobs(self):
        """Scrape jobs from peer relation data will be generated by this method."""
        pass

if __name__ == "__main__":  # pragma: nocover
    ops.main(BlackboxExporterOperatorCharm)
