#!/usr/bin/env python3
# Copyright 2026 sina.pahlavan@canonical.com
# See LICENSE file for licensing details.

"""Charm the application."""

import logging
import shutil
import os
import ops
from charms.prometheus_k8s.v0.prometheus_scrape import MetricsEndpointProvider
from charms.operator_libs_linux.v2 import snap 
from constants import PROBES_RELATION_NAME
from ops import BlockedStatus, CharmBase, RelationChangedEvent
from ops.model import ActiveStatus, MaintenanceStatus, WaitingStatus
from singleton_snap import SingletonSnapManager, SnapRegistrationFile
from snap_management import (
    SnapMap,
    SnapServiceError,
    SnapSpecError,
    install_snap,
)

logger = logging.getLogger(__name__)

def event() -> str:
    """Return Juju hook|action name.

    Refs:
    - https://github.com/juju/juju/blob/cbb05654c7444dd6bee29e49aff16339f02c34f9/docs/reference/action.md?plain=1#L55
    - https://github.com/juju/juju/blob/cbb05654c7444dd6bee29e49aff16339f02c34f9/docs/reference/hook.md?plain=1#L1088
    """
    return os.environ.get("JUJU_HOOK_NAME") or os.environ.get("JUJU_ACTION_NAME", "")

class BlackboxExporterOperatorCharm(ops.CharmBase):
    """Charm the application."""

    def __init__(self, framework: ops.Framework):
        super().__init__(framework)
        if event() in ("install", "upgrade"):
            self._install_snaps()
        elif event() == "remove":
            # NOTE: We need to clean up the config file and uninstall the snap(s). If we do this
            # on the stop hook, then it will be reverted by the reconciler on `peer_relation_*`
            # hooks. Instead of filtering out these hooks, we do everything in the remove hook.
            # https://documentation.ubuntu.com/juju/3.6/reference/hook/#remove
            self._cleanup_certificates_on_remove()
            self._remove_node_exporter()
            self._remove_opentelemetry_collector()
            return

        self._scraping = MetricsEndpointProvider(
            self,
            relation_name=PROBES_RELATION_NAME,
            jobs=[], # TODO: this needs to be equal to the jobs specified by _generate_scrape_jobs and the probes_file config option (to be added)
            refresh_event=[
                self.on.config_changed,
                self.on.update_status,
            ],
        )

    def snap(self, snap_name: str) -> snap.Snap:
        """Return the snap object for the given snap.

        This method provides lazy initialization of snap objects, avoiding unnecessary
        calls to snapd until they're actually needed.
        """
        return snap.SnapCache()[snap_name]
    
    def _install_snaps(self) -> None:
        manager = SingletonSnapManager(self.unit.name)

        for snap_name in SnapMap.snaps():
            snap_revision = SnapMap.get_revision(snap_name)
            manager.register(snap_name, snap_revision)
            revisions = manager.get_revisions(snap_name)
            if snap_revision >= (max(revisions) if revisions else 0):
                # Install the snap
                self.unit.status = MaintenanceStatus(f"Installing {snap_name} snap")
                install_snap(snap_name)
                # Start the snap
                self.unit.status = MaintenanceStatus(f"Starting {snap_name} snap")
                try:
                    self.snap(snap_name).start(enable=True)
                except snap.SnapError as e:
                    raise SnapServiceError(f"Failed to start {snap_name}") from e

    def _remove_blackbox_exporter(self):
        """Coordinate blackbox-exporter snap and config file removal."""
        manager = SingletonSnapManager(self.unit.name)
        snap_name = "prometheus-blackbox-exporter"
        snap_revision = SnapMap.get_revision(snap_name)
        manager.unregister(snap_name, snap_revision)
        if manager.is_used_by_other_units(snap_name):
            try:
                self.snap("prometheus-blackbox-exporter").restart()
            except snap.SnapError as e:
                logger.warning(f"Failed to restart prometheus-blackbox-exporter snap: {e}")
        else:
            try:
                self._remove_snap(snap_name)
                logger.info(f"Removed the prometheus-blackbox-exporter snap")
            except Exception as e:
                logger.warning(f"Unable to remove the prometheus-blackbox-exporter snap: {e}")

    def _generate_scrape_jobs(self):
        """Scrape jobs from peer relation data will be generated by this method."""
        pass

if __name__ == "__main__":  # pragma: nocover
    ops.main(BlackboxExporterOperatorCharm)
